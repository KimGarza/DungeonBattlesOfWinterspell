#include <vector>
#include <string>
#include <iostream>
#include "DungeonGenerator.h"
#include "DungeonRoom.h"
#include <random>
#include <vector>
#include <memory>
#include <cstdlib>
#include <ctime>
#include "Enemies.h"
#include "IEnemy.h"


/// <summary>
/// Acts as a factory producing dungeons without concretely creating seperate dungeon classes, and each time generates random enemies to spawn within.
/// Currently all happening at once at the start of the game rather than one by one throughout to reduce complexity in the flow.
/// </summary>
/// <returns></returns>
std::vector < std::shared_ptr<DungeonRoom>> DungeonGenerator::GenerateDungeons() {

    std::vector<std::shared_ptr<DungeonRoom>> dungeonRooms;

    int roomLevel = 1;

    for (const auto& dungeon : dungeonList) {

        std::vector<std::shared_ptr<IEnemy>> enemyList = GenerateEnemies(roomLevel);

        std::shared_ptr<DungeonRoom> newDungeonRoom = std::make_shared<DungeonRoom>(dungeon.first, dungeon.second, roomLevel, enemyList);
        dungeonRooms.push_back(newDungeonRoom);

        roomLevel++;
    }

    return dungeonRooms;
}


/// <summary>
/// Generates a list of all possible enemy types, random number of enemies accounted for returning in the list based upon the level of the room. Lower levels have less enemies. Randomizes which enemies are chosen from the list.
/// Would like to later come back and make troll scarier by references ES Arena
/// </summary>
/// <param name="roomLevel"></param>
/// <returns></returns>
std::vector<std::shared_ptr<IEnemy>> DungeonGenerator::GenerateEnemies(int roomLevel) {

    std::vector<std::shared_ptr<IEnemy>> enemies;
    enemies.push_back(std::make_shared<Firespitter>());
    enemies.push_back(std::make_shared<DungeonDweller>());
    enemies.push_back(std::make_shared<Goblin>());
    enemies.push_back(std::make_shared<HauntingSpirit>());
    enemies.push_back(std::make_shared<Troll>());
    enemies.push_back(std::make_shared<Skeleton>());
    enemies.push_back(std::make_shared<UndeadWolf>());

    // Gets random number between the min/max which are decided based upon what the room levels are. Represents how many enemies can spawn per room. (Maximum & minimum values inclusive).
    std::random_device rand; /**/ std::mt19937 gen(rand()); /**/ int min_value = 0; /**/ int max_value = 0;

    if (roomLevel < 3) {
        min_value = 2; max_value = 4;
    } else if (roomLevel < 5) {
        min_value = 3; max_value = 6;
    } else {
        min_value = 4; max_value = 7;
    }

    std::uniform_int_distribution<int> distribution(min_value, max_value);

    int random_number = distribution(gen); // random_number is how many enemies can spawn per room


    std::vector<std::shared_ptr<IEnemy>> enemiesInRoom; /**/ int randomIndex = 0;

    for (int i = 0; i < random_number; i++) {

        if (roomLevel < 3) {
            int lowLevel = (enemies.size() + 3) / 4; // Adding 3 before dividing by 4 effectively rounds up
            randomIndex = std::rand() % lowLevel; // truncates 
            // The expression std::rand() % enemies.size() computes the remainder when the random number generated by std::rand() is divided by the number of elements in the enemies vector.
            // The remainder will always be in the range 0 to enemies.size() - 1. This is because the remainder of any division operation is always less than the divisor.

        } else if (roomLevel < 5) {
            int medLevel = (enemies.size() + 3) / 2;
            randomIndex = std::rand() % medLevel;
        } else {
            randomIndex = std::rand() % enemies.size();
        }

        std::shared_ptr<IEnemy> randomEnemy = enemies[randomIndex];

        enemiesInRoom.push_back(randomEnemy);
    }

    return enemiesInRoom;
}