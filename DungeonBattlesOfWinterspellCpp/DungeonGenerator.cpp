#include <vector>
#include <string>
#include <iostream>
#include "DungeonGenerator.h"
#include "DungeonRoom.h"
#include <random>
#include <vector>
#include <memory>
#include <cstdlib>
#include <ctime>
#include "Enemies.h"
#include "ItemTypes.h"
#include "IEnemy.h"


/// <summary>
/// Acts as a factory producing dungeons without concretely creating seperate dungeon classes, and each time generates random enemies to spawn within.
/// Currently all happening at once at the start of the game rather than one by one throughout to reduce complexity in the flow.
/// </summary>
/// <returns></returns>
std::vector < std::shared_ptr<DungeonRoom>> DungeonGenerator::GenerateDungeons() {

    std::vector<std::shared_ptr<DungeonRoom>> dungeonRooms;

    int roomLevel = 1;

    for (const auto& dungeon : dungeonList) {

        std::vector<std::shared_ptr<IEnemy>> enemyList = GenerateEnemies(roomLevel);
        std::vector<std::shared_ptr<LootItem>> loot = GenerateLoot();

        if (dungeon.first == "Hozwardian Keep" || dungeon.first == "Room of Offerings") { // lock these two rooms
            std::shared_ptr<DungeonRoom> newDungeonRoom = std::make_shared<DungeonRoom>(dungeon.first, dungeon.second, roomLevel, true, enemyList, loot);
        }
        else {
            std::shared_ptr<DungeonRoom> newDungeonRoom = std::make_shared<DungeonRoom>(dungeon.first, dungeon.second, roomLevel, false, enemyList, loot);
            dungeonRooms.push_back(newDungeonRoom);
        }

        roomLevel++;
    }

    return dungeonRooms;
}


/// <summary>
/// Generates a list of all possible enemy types, random number of enemies accounted for returning in the list based upon the level of the room. Lower levels have less enemies. Randomizes which enemies are chosen from the list.
/// Would like to later come back and make troll scarier by references ES Arena
/// </summary>
/// <param name="roomLevel"></param>
/// <returns></returns>
std::vector<std::shared_ptr<IEnemy>> DungeonGenerator::GenerateEnemies(int roomLevel) {

    std::vector<std::shared_ptr<IEnemy>> enemies;
    enemies.push_back(std::make_shared<Firespitter>());
    enemies.push_back(std::make_shared<DungeonDweller>());
    enemies.push_back(std::make_shared<Goblin>());
    enemies.push_back(std::make_shared<HauntingSpirit>());
    enemies.push_back(std::make_shared<Troll>());
    enemies.push_back(std::make_shared<Skeleton>());
    enemies.push_back(std::make_shared<UndeadWolf>());

    // Gets random number between the min/max which are decided based upon what the room levels are. Represents how many enemies can spawn per room. (Maximum & minimum values inclusive).
    std::random_device rand; /**/ std::mt19937 gen(rand()); /**/ int min_value = 0; /**/ int max_value = 0;

    //if (roomLevel < 3) {
        //min_value = 2; max_value = 4;
        min_value = 1; max_value = 1;
    //} else if (roomLevel < 5) {
    //    //min_value = 3; max_value = 6;
    //    min_value = 1; max_value = 1;

    //} else {
    //    //min_value = 4; max_value = 7;
    //    min_value = 1; max_value = 1;

    //}

    std::uniform_int_distribution<int> distribution(min_value, max_value);

    int random_number = distribution(gen); // random_number is how many enemies can spawn per room


    std::vector<std::shared_ptr<IEnemy>> enemiesInRoom; /**/ int randomIndex = 0;

    for (int i = 0; i < random_number; i++) {

        //if (roomLevel < 3) {
            int lowLevel = (enemies.size() + 3) / 4; // Adding 3 before dividing by 4 effectively rounds up
            randomIndex = std::rand() % lowLevel; // truncates 
            // The expression std::rand() % enemies.size() computes the remainder when the random number generated by std::rand() is divided by the number of elements in the enemies vector.
            // The remainder will always be in the range 0 to enemies.size() - 1. This is because the remainder of any division operation is always less than the divisor.

        //} else if (roomLevel < 5) {
        //    int medLevel = (enemies.size() + 3) / 2;
        //    randomIndex = std::rand() % medLevel;
        //} else {
        //    randomIndex = std::rand() % enemies.size();
        //}

        std::shared_ptr<IEnemy> randomEnemy = enemies[randomIndex];

        enemiesInRoom.push_back(randomEnemy);
    }

    return enemiesInRoom;
}

std::vector<std::shared_ptr<LootItem>> DungeonGenerator::GenerateLoot() {

    std::vector<std::shared_ptr<LootItem>> lootInRoom;

    std::vector<std::shared_ptr<LootItem>> lootStock{
        std::make_shared<LootItem>("Gold Coin", ItemType::Currency, "a very valueable piece of currency; Can be used for purchasing in the markets.", 1),
        std::make_shared<LootItem>("Silver Coin", ItemType::Currency, "a valueable piece of currency; Can be used for purchasing in the markets.", .5),
        std::make_shared<LootItem>("Ruby Gem", ItemType::Currency, "a dazzling rich red jewel; Tradeable for cold coin", 4),
        std::make_shared<LootItem>("Starlight Gem", ItemType::Currency, "a valueable piece of currency; can be used to purchase things in the markets.", 2),
        std::make_shared<LootItem>("Moonstone", ItemType::Currency, "a valueable piece of currency; can be used to purchase things in the markets.", 1),
        std::make_shared<LootItem>("Luminescent Mushie", ItemType::Currency, "a valueable piece of currency; can be used to purchase things in the markets.", 1),
        std::make_shared<LootItem>("Key", ItemType::Key, "for unlocking doors of course.", 1),
        std::make_shared<LootItem>("Ancient Scroll", ItemType::AncientScroll, "hidden secrets are etched upon a tattered sturdy cloth.", 1),
        std::make_shared<LootItem>("Jewel Encrested Chalice", ItemType::Currency, "a beautifully ornately crafted chalice, encrested in colorful polished jewels, looks of dwarven-make.", 1),
        std::make_shared<LootItem>("Health Potion", ItemType::HealthPotion, "which restores 20 HP.", 1),
        std::make_shared<LootItem>("Boots of Swiftness", ItemType::Equiptment, "which gives wearer swiftness.", 1),
        std::make_shared<LootItem>("Helm of Protection", ItemType::Equiptment, "+10 to armour.", 1, 10),
        std::make_shared<LootItem>("Steel Chestplate", ItemType::Equiptment, "+20 to armour.", 1, 10, 20),
        std::make_shared<LootItem>("Leather Guantlets", ItemType::Equiptment, "+5 to armour.", 1, 10, 5),
        std::make_shared<LootItem>("Palantíri", ItemType::Currency, "an orb of pondering, it can see things that may not be meant for our eyes. Looks to belong to a wise mage or wizard.", 1),
    };

    std::random_device rd;  // Obtain a random number from hardware
    std::mt19937 gen(rd()); // Seed the generator
    std::uniform_int_distribution<> distr(1, 4); // Define the range
    // Generate and print a random number between 1 and 10
    int randomNumber = distr(gen);


    for (int i = 0; i < randomNumber; i++) {

        std::uniform_int_distribution<> distr(0, lootStock.size() - 1);
        int randomLootPull = distr(gen);

        lootInRoom.push_back(lootStock[randomLootPull]);
    }
    return lootInRoom;

}
